use anyhow::{bail, Context, Result};
use serde::Deserialize;
use std::{
    fs::{self, File},
    io::Write,
    path::{Path, PathBuf},
};

pub const CONFIG_FILENAME: &str = "sheafy.toml";
pub const DEFAULT_BUNDLE_NAME: &str = "project_bundle.md";
// Updated default config content
pub const DEFAULT_CONFIG_CONTENT: &str = r#"[sheafy]
# Output filename for bundle command
bundle_name = "project_bundle.md"

# Optional working directory (relative to config file)
# working_dir = "."

# Whether to respect .gitignore files (default: true)
use_gitignore = true

# Optional: Add custom ignore patterns (multi-line string, gitignore syntax)
# These patterns are applied *in addition* to .gitignore rules (if enabled).
# Example: ignore all '.log' files and the 'temp/' directory
# ignore_patterns = """
# *.log
# temp/
# """

# Optional prologue text to include at start of bundle
# prologue = """
# # Project Bundle
#
# This file contains all project source code.
# """

# Optional epilogue text to include at end of bundle
# epilogue = """
# ## End of Bundle
#
# Generated by sheafy
# """
"#;

#[derive(Deserialize, Debug, Default)]
pub struct SheafyConfig {
    // REMOVED: pub filters: Option<Vec<String>>,
    pub bundle_name: Option<String>,
    pub working_dir: Option<String>,
    pub use_gitignore: Option<bool>,
    pub prologue: Option<String>,
    pub epilogue: Option<String>,
    // ADDED: ignore_patterns field
    pub ignore_patterns: Option<String>,
}

#[derive(Deserialize, Debug, Default)]
pub struct Config {
    #[serde(default)]
    pub sheafy: SheafyConfig,
}

impl Config {
    pub fn load() -> Result<Self> {
        let config_path = Path::new(CONFIG_FILENAME);
        if config_path.exists() {
            let config_content = fs::read_to_string(config_path)
                .with_context(|| format!("Failed to read config file: {}", CONFIG_FILENAME))?;
            toml::from_str(&config_content)
                .with_context(|| format!("Failed to parse config file: {}", CONFIG_FILENAME))
        } else {
            Ok(Self::default())
        }
    }

    pub fn init() -> Result<()> {
        let config_path = Path::new(CONFIG_FILENAME);
        if config_path.exists() {
            bail!("Config file already exists at {}", config_path.display());
        }

        let mut file = File::create(config_path)
            .with_context(|| format!("Failed to create config file: {}", CONFIG_FILENAME))?;
        file.write_all(DEFAULT_CONFIG_CONTENT.as_bytes())
            .with_context(|| format!("Failed to write config file: {}", CONFIG_FILENAME))?;

        println!("Created default config file at {}", config_path.display());
        Ok(())
    }

    pub fn get_working_dir(&self) -> Result<PathBuf> {
        let current_dir =
            std::env::current_dir().context("Failed to get current working directory")?;
        if let Some(working_dir) = &self.sheafy.working_dir {
            let working_dir_path = current_dir.join(working_dir);
            if working_dir_path.exists() {
                Ok(working_dir_path.canonicalize().with_context(|| format!("Failed to canonicalize working directory path: {}", working_dir_path.display()))?) // Canonicalize for consistency
            } else {
                bail!(
                    "Working directory does not exist: {}",
                    working_dir_path.display()
                );
            }
        } else {
            Ok(current_dir)
        }
    }
}
